<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Matt Greer</title>
    <atom:link href="http://mattgreer.org/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://mattgreer.org</link>
    <description>Me talking about software and programming</description>
    <pubDate>Sat, 08 Feb 2014 17:00:00 -0700</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>JavaScript Promises ... In Wicked Detail</title>
      <link>http://mattgreer.org/articles/promises-in-wicked-detail/</link>
      <pubDate>Sat, 08 Feb 2014 17:00:00 -0700</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/promises-in-wicked-detail/</guid>
      <author></author>
      <description>&lt;p&gt;I’ve been using promises in my JavaScript code for a while now. They can be a little brain bending at first. I now use them pretty effectively, but when it came down to it, I didn’t fully understand how they work. This article is my resolution to that. If you stick around until the end, you should understand promises well too. &lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We will be incrementally creating a promise implementation that by the end will &lt;em&gt;mostly&lt;/em&gt; meet the &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ spec&lt;/a&gt;, and understand how promises meet the needs of asynchronous programming along the way. This article assumes you already have some familiarity with promises. If you don’t, &lt;a href=&quot;http://promisejs.org/&quot;&gt;promisejs.org&lt;/a&gt; is a good site to checkout.&lt;/p&gt;
&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#why-&quot;&gt;Why?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-simplest-use-case&quot;&gt;The Simplest Use Case&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#defining-the-promise-type&quot;&gt;Defining the Promise type&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#this-code-is-brittle-and-bad&quot;&gt;This Code is Brittle and Bad&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#promises-have-state&quot;&gt;Promises have State&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#chaining-promises&quot;&gt;Chaining Promises&lt;/a&gt;
     &lt;ul&gt;
       &lt;li&gt;&lt;a href=&quot;#the-callback-is-optional&quot;&gt;The Callback is Optional&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;&lt;a href=&quot;#returning-promises-inside-the-chain&quot;&gt;Returning Promises Inside the Chain&lt;/a&gt;&lt;/li&gt;
    &lt;/li&gt;
    &lt;/ul&gt;
    &lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#rejecting-promises&quot;&gt;Rejecting Promises&lt;/a&gt;
   &lt;ul&gt;
     &lt;li&gt;&lt;a href=&quot;#unexpected-errors-should-also-lead-to-rejection&quot;&gt;Unexpected Errors Should Also Lead to Rejection&lt;/a&gt;&lt;/li&gt;
     &lt;li&gt;&lt;a href=&quot;#promises-can-swallow-errors-&quot;&gt;Promises Can Swallow Errors!&lt;/a&gt;&lt;/li&gt;
     &lt;li&gt;&lt;a href=&quot;#done-to-the-rescue&quot;&gt;done() to the Rescue&lt;/a&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#promise-resolution-needs-to-be-async&quot;&gt;Promise Resolution Needs to be Async&lt;/a&gt;
   &lt;ul&gt;
     &lt;li&gt;&lt;a href=&quot;#why-is-this-async-requirement-in-the-spec-&quot;&gt;Why is this Async Requirement in the Spec?&lt;/a&gt;
     &lt;/li&gt;
   &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#before-we-wrap-up-then-promise&quot;&gt;Before We Wrap Up … then/promise&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;#further-reading&quot;&gt;Further Reading&lt;/a&gt;&lt;/li&gt;

&lt;/ol&gt;

&lt;h2 id=&quot;why-&quot;&gt;Why?&lt;/h2&gt;
&lt;p&gt;Why bother to understand promises to this level of detail? Really understanding how something works can increase your ability to take advantage of it, and debug it more successfully when things go wrong. I was inspired to write this article when a coworker and I got stumped on a tricky promise scenario. Had I known then what I know now, we wouldn’t have gotten stumped.&lt;/p&gt;
&lt;h2 id=&quot;the-simplest-use-case&quot;&gt;The Simplest Use Case&lt;/h2&gt;
&lt;p&gt;Let’s begin our promise implementation as simple as can be. We want to go from this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Got a value:'&lt;/span&gt; value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Got a value:'&lt;/span&gt; value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do this, we just need to change &lt;code&gt;doSomething()&lt;/code&gt; from this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(callback)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;
  callback(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to this “promise” based solution&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; {
    then: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(callback)&lt;/span&gt; {&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;
      callback(value);
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/zdgrC/1/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is just a little sugar for the callback pattern. It’s pretty pointless sugar so far. But it’s a start and yet we’ve already hit upon a core idea behind promises&lt;/p&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
Promises capture the notion of an eventual value into an object
&lt;/div&gt;

&lt;p&gt;This is the main reason promises are so interesting. Once the concept of eventuality is captured like this, we can begin to do some very powerful things. We’ll explore this more later on.&lt;/p&gt;
&lt;h3 id=&quot;defining-the-promise-type&quot;&gt;Defining the Promise type&lt;/h3&gt;
&lt;p&gt;This simple object literal isn’t going to hold up. Let’s define an actual &lt;code&gt;Promise&lt;/code&gt; type that we’ll be able to expand upon&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fn)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callback = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cb)&lt;/span&gt; {&lt;/span&gt;
    callback = cb;
  };

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
    callback(value);
  }

  fn(resolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and reimplement &lt;code&gt;doSomething()&lt;/code&gt; to use it&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(resolve)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;
    resolve(value);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a problem here. If you trace through the execution, you’ll see that &lt;code&gt;resolve()&lt;/code&gt; gets called before &lt;code&gt;then()&lt;/code&gt;, which means &lt;code&gt;callback&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;. Let’s hide this problem in a little hack involving &lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fn)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callback = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cb)&lt;/span&gt; {&lt;/span&gt;
    callback = cb;
  };

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// force callback to be called in the next&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// iteration of the event loop, giving&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// callback a chance to be set by then()&lt;/span&gt;
    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
      callback(value);
    }, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);
  }

  fn(resolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/uQrza/1/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With the hack in place, this code now works … sort of.&lt;/p&gt;
&lt;h3 id=&quot;this-code-is-brittle-and-bad&quot;&gt;This Code is Brittle and Bad&lt;/h3&gt;
&lt;p&gt;Our naive, poor promise implementation must use asynchronicity to work. It’s easy to make it fail again, just call &lt;code&gt;then()&lt;/code&gt; asynchronously and we are right back to the callback being &lt;code&gt;null&lt;/code&gt; again. Why am I setting you up for failure so soon? Because the above implementation has the advantage of being pretty easy to wrap your head around. &lt;code&gt;then()&lt;/code&gt; and &lt;code&gt;resolve()&lt;/code&gt; won’t go away. They are key concepts in promises.&lt;/p&gt;
&lt;h2 id=&quot;promises-have-state&quot;&gt;Promises have State&lt;/h2&gt;
&lt;p&gt;Our brittle code above revealed something unexpectedly. Promises have state. We need to know what state they are in before proceeding, and make sure we move through the states correctly. Doing so gets rid of the brittleness. &lt;/p&gt;
&lt;div class=&quot; callout wisdom&quot;&gt;
&lt;ul&gt;
&lt;li&gt;A promise can be &lt;strong&gt;pending&lt;/strong&gt; waiting for a value, or &lt;strong&gt;resolved&lt;/strong&gt; with a value. 
&lt;li&gt;Once a promise resolves to a value, it will always remain at that value and never resolve again.
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;(A promise can also be rejected, but we’ll get to error handling later)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let’s explicitly track the state inside of our implementation, which will allow us to do away with our hack&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fn)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred;

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; {&lt;/span&gt;
    value = newValue;
    state = &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) {
      handle(deferred);
    }
  }

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(onResolved)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;) {
      deferred = onResolved;
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }

    onResolved(value);
  }

  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(onResolved)&lt;/span&gt; {&lt;/span&gt;
    handle(onResolved);
  };

  fn(resolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/QX85J/1/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It’s getting more complicated, but the caller can invoke &lt;code&gt;then()&lt;/code&gt; whenever they want, and the callee can invoke &lt;code&gt;resolve()&lt;/code&gt; whenever they want. It fully works with synchronous or asynchronous code.&lt;/p&gt;
&lt;p&gt;This is because of the &lt;code&gt;state&lt;/code&gt; flag. Both &lt;code&gt;then()&lt;/code&gt; and &lt;code&gt;resolve()&lt;/code&gt; hand off to the new method &lt;code&gt;handle()&lt;/code&gt;, which will do one of two things depending on the situation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The caller has called &lt;code&gt;then()&lt;/code&gt; before the callee calls &lt;code&gt;resolve()&lt;/code&gt;, that means there is no value ready to hand back. In this case the state will be pending, and so we hold onto the caller’s callback to use later. Later when &lt;code&gt;resolve()&lt;/code&gt; gets called, we can then invoke the callback and send the value on its way.&lt;/li&gt;
&lt;li&gt;The callee calls &lt;code&gt;resolve()&lt;/code&gt; before the caller calls &lt;code&gt;then()&lt;/code&gt;: In this case we hold onto the resulting value. Once &lt;code&gt;then()&lt;/code&gt; gets called, we are ready to hand back the value.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice &lt;code&gt;setTimeout&lt;/code&gt; went away? That’s temporary, it will be coming back. But one thing at a time.&lt;/p&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
With promises, the order in which we work with them doesn’t matter. We are free to call &lt;code&gt;then()&lt;/code&gt; and &lt;code&gt;resolve()&lt;/code&gt; whenever they suit our purposes. This is one of the powerful advantages of capturing the notion of eventual results into an object
&lt;/div&gt;

&lt;p&gt;We still have quite a few more things in the spec to implement, but our promises are already pretty powerful. This system allows us to call &lt;code&gt;then()&lt;/code&gt; as many times as we want, we will always get the same value back&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = doSomething();

promise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Got a value:'&lt;/span&gt;, value);
});

promise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Got the same value again:'&lt;/span&gt;, value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
This is not completely true for the promise implementation in this article. If the opposite happens, ie the caller calls &lt;code&gt;then()&lt;/code&gt; multiple times before &lt;code&gt;resolve()&lt;/code&gt; is called, only the last call to &lt;code&gt;then()&lt;/code&gt; will be honored. The fix for this is to keep a running list of deferreds inside of the promise instead of just one. I decided to not do that in the interest of keeping the article more simple, it’s long enough as it is :)
&lt;/div&gt;

&lt;h2 id=&quot;chaining-promises&quot;&gt;Chaining Promises&lt;/h2&gt;
&lt;p&gt;Since promises capture the notion of asynchronicity in an object, we can chain them, map them, have them run in parallel or sequential, all kinds of useful things. Code like the following is very common with promises&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;getSomeData()
.then(filterTheData)
.then(processTheData)
.then(displayTheData);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getSomeData&lt;/code&gt; is returning a promise, as evidenced by the call to &lt;code&gt;then()&lt;/code&gt;, but the result of that first then must also be a promise, as we call &lt;code&gt;then()&lt;/code&gt; again (and yet again!) That’s exactly what happens, if we can convince &lt;code&gt;then()&lt;/code&gt; to return a promise, things get more interesting.&lt;/p&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
&lt;code&gt;then()&lt;/code&gt; always returns a promise
&lt;/div&gt;

&lt;p&gt;Here is our promise type with chaining added in&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fn)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; {&lt;/span&gt;
    value = newValue;
    state = &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) {
      handle(deferred);
    }
  }

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(handler)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;) {
      deferred = handler;
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handler.onResolved) {
      handler.resolve(value);
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handler.onResolved(value);
    handler.resolve(ret);
  }

  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(onResolved)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(resolve)&lt;/span&gt; {&lt;/span&gt;
      handle({
        onResolved: onResolved,
        resolve: resolve
      });
    });
  };

  fn(resolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/HdzLv/2/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hoo, it’s getting a little squirrelly. Aren’t you glad we’re building this up slowly? The real key here is that &lt;code&gt;then()&lt;/code&gt; is returning a new promise. &lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
Since &lt;code&gt;then()&lt;/code&gt; always returns a new promise object, there will always be at least one promise object that gets created, resolved and then ignored. Which can be seen as wasteful. The callback approach does not have this problem. Another ding against promises. You can start to appreciate why some in the JavaScript community have shunned them.
&lt;/div&gt;

&lt;p&gt;What value does the second promise resolve to? &lt;em&gt;It receives the return value of the first promise.&lt;/em&gt; This is happening at the bottom of &lt;code&gt;handle()&lt;/code&gt;, The &lt;code&gt;handler&lt;/code&gt; object carries around both an &lt;code&gt;onResolved&lt;/code&gt; callback as well as a reference to &lt;code&gt;resolve()&lt;/code&gt;. There is more than one copy of &lt;code&gt;resolve()&lt;/code&gt; floating around, each promise gets their own copy of this function, and a closure for it to run within. This is the bridge from the first promise to the second. We are concluding the first promise at this line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handler.onResolved(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the examples I’ve been using here, &lt;code&gt;handler.onResolved&lt;/code&gt; is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;&quot;Got a value:&quot;&lt;/span&gt;, value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in other words, it’s what was passed into the first call to &lt;code&gt;then()&lt;/code&gt;. The return value of that first handler is used to resolve the second promise. Thus chaining is accomplished&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'first result'&lt;/span&gt;, result);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(secondResult)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'second result'&lt;/span&gt;, secondResult);
});

&lt;span class=&quot;comment&quot;&gt;// the output is&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// first result 42&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// second result 88&lt;/span&gt;


doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'first result'&lt;/span&gt;, result);
  &lt;span class=&quot;comment&quot;&gt;// not explicitly returning anything&lt;/span&gt;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(secondResult)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'second result'&lt;/span&gt;, secondResult);
});

&lt;span class=&quot;comment&quot;&gt;// now the output is&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// first result 42&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// second result undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;then()&lt;/code&gt; always returns a new promise, this chaining can go as deep as we like&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'first result'&lt;/span&gt;, result);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(secondResult)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'second result'&lt;/span&gt;, secondResult);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(thirdResult)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'third result'&lt;/span&gt;, thirdResult);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fourthResult)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// on and on...&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if in the above example, we wanted all the results in the end? With chaining, we would need to manually build up the result ourself&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results = [result];
  results.push(&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; results;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(results)&lt;/span&gt; {&lt;/span&gt;
  results.push(&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; results;
}).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(results)&lt;/span&gt; {&lt;/span&gt;
  console.log(results.join(&lt;span class=&quot;string&quot;&gt;', '&lt;/span&gt;);
});

&lt;span class=&quot;comment&quot;&gt;// the output is&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// 42, 88, 99&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
  Promises always resolve to one value. If you need to pass more than one value along, you need to create a multi-value in some fashion (an array, an object, concatting strings, etc)
&lt;/div&gt;

&lt;p&gt;A potentially better way is to use a promise library’s &lt;code&gt;all()&lt;/code&gt; method or any number of other utility methods that increase the usefulness of promises, which I’ll leave to you to go and discover. &lt;/p&gt;
&lt;h3 id=&quot;the-callback-is-optional&quot;&gt;The Callback is Optional&lt;/h3&gt;
&lt;p&gt;The callback to &lt;code&gt;then()&lt;/code&gt; is not strictly required. If you leave it off, the promise resolves to the same value as the previous promise&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'got a result'&lt;/span&gt;, result);
});

&lt;span class=&quot;comment&quot;&gt;// the output is&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// got a result 42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see this inside of &lt;code&gt;handle()&lt;/code&gt;, where if there is no callback, it simply resolves the promise and exits. &lt;code&gt;value&lt;/code&gt; is still the value of the previous promise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handler.onResolved) {
  handler.resolve(value);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;returning-promises-inside-the-chain&quot;&gt;Returning Promises Inside the Chain&lt;/h3&gt;
&lt;p&gt;Our chaining implementation is a bit naive. It’s blindly passing the resolved values down the line. What if one of the resolved values is a promise? For example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(result) {
  &lt;span class=&quot;comment&quot;&gt;// doSomethingElse returns a promise&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; doSomethingElse(result)
}.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(finalResult)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;&quot;the final result is&quot;&lt;/span&gt;, finalResult);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it stands now, the above won’t do what we want. &lt;code&gt;finalResult&lt;/code&gt; won’t actually be a fully resolved value, it will instead be a promise. To get the intended result, we’d need to do&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(result) {
  &lt;span class=&quot;comment&quot;&gt;// doSomethingElse returns a promise&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; doSomethingElse(result)
}.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anotherPromise)&lt;/span&gt; {&lt;/span&gt;
  anotherPromise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(finalResult)&lt;/span&gt; {&lt;/span&gt;
    console.log(&lt;span class=&quot;string&quot;&gt;&quot;the final result is&quot;&lt;/span&gt;, finalResult);
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Who wants that crud in their code? Let’s have the promise implementation seamlessly handle this for us. This is simple to do, inside of &lt;code&gt;resolve()&lt;/code&gt; just add a special case if the resolved value is a promise&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(newValue &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; newValue.then === &lt;span class=&quot;string&quot;&gt;'function'&lt;/span&gt;) {
    newValue.then(resolve);
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
  }
  state = &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;;
  value = newValue;

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) {
    handle(deferred);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/38CCb/2/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We’ll keep calling &lt;code&gt;resolve()&lt;/code&gt; recursively as long as we get a promise back. Once it’s no longer a promise, then proceed as before.&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
It &lt;em&gt;is&lt;/em&gt; possible for this to be an infinite loop. The Promises/A+ spec recommends implementations detect infinite loops, but it’s not required.
&lt;/div&gt;

&lt;div class=&quot;callout pitfall&quot;&gt;
Also worth pointing out, this implementation does not meet the spec. Nor will we fully meet the spec in this regard in the article. For the more curious, I recommend reading the &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/#the_promise_resolution_procedure&quot;&gt;promise resolution procedure&lt;/a&gt;.
&lt;/div&gt;

&lt;p&gt;Notice how loose the check is to see if &lt;code&gt;newValue&lt;/code&gt; is a promise? We are only looking for a &lt;code&gt;then()&lt;/code&gt; method. This duck typing is intentional, it allows different promise implementations to interopt with each other. It’s actually quite common for promise libraries to intermingle, as different third party libraries you use can each use different promise implementations.&lt;/p&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
Different promise implementations can interopt with each other, as long as they all are following the spec properly.
&lt;/div&gt;

&lt;p&gt;With chaining in place, our implementation is pretty complete. But we’ve completely ignored error handling.&lt;/p&gt;
&lt;h2 id=&quot;rejecting-promises&quot;&gt;Rejecting Promises&lt;/h2&gt;
&lt;p&gt;When something goes wrong during the course of a promise, it needs to be &lt;strong&gt;rejected&lt;/strong&gt; with a &lt;em&gt;reason&lt;/em&gt;. How does the caller know when this happens? They can find out by passing in a second callback to &lt;code&gt;then()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Success!'&lt;/span&gt;, value);
}, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(error)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'Uh oh'&lt;/span&gt;, error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
As mentioned earlier, the promise will transition from &lt;strong&gt;pending&lt;/strong&gt; to either &lt;strong&gt;resolved&lt;/strong&gt; or &lt;strong&gt;rejected&lt;/strong&gt;, never both. In other words, only one of the above callbacks ever gets called.
&lt;/div&gt;

&lt;p&gt;Promises enable rejection by means of &lt;code&gt;reject()&lt;/code&gt;, the evil twin of &lt;code&gt;resolve()&lt;/code&gt;. Here is &lt;code&gt;doSomething()&lt;/code&gt; with error handling support added&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(resolve, reject)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = somehowGetTheValue(); 
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(result.error) {
      reject(result.error);
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
      resolve(result.value);
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside the promise implementation, we need to account for rejection. As soon as a promise is rejected, all downstream promises from it also need to be rejected.&lt;/p&gt;
&lt;p&gt;Let’s see the full promise implementation again, this time with rejection support added&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fn)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(newValue &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; newValue.then === &lt;span class=&quot;string&quot;&gt;'function'&lt;/span&gt;) {
      newValue.then(resolve, reject);
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }
    state = &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;;
    value = newValue;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) {
      handle(deferred);
    }
  }

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(reason)&lt;/span&gt; {&lt;/span&gt;
    state = &lt;span class=&quot;string&quot;&gt;'rejected'&lt;/span&gt;;
    value = reason;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) {
      handle(deferred);
    }
  }

  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(handler)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;) {
      deferred = handler;
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; handlerCallback;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;) {
      handlerCallback = handler.onResolved;
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
      handlerCallback = handler.onRejected;
    }

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handlerCallback) {
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'resolved'&lt;/span&gt;) {
        handler.resolve(value);
      } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        handler.reject(value);
      }

      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handlerCallback(value);
    handler.resolve(ret);
  }

  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(onResolved, onRejected)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(resolve, reject)&lt;/span&gt; {&lt;/span&gt;
      handle({
        onResolved: onResolved,
        onRejected: onRejected,
        resolve: resolve,
        reject: reject
      });
    });
  };

  fn(resolve, reject);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/rLXsL/2/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Other than the addition of &lt;code&gt;reject()&lt;/code&gt; itself, &lt;code&gt;handle()&lt;/code&gt; also has to be aware of rejection. Within &lt;code&gt;handle()&lt;/code&gt;, either the rejection path or resolve path will be taken depending on the value of &lt;code&gt;state&lt;/code&gt;. This value of &lt;code&gt;state&lt;/code&gt; gets pushed into the next promise, because calling the next promises’ &lt;code&gt;resolve()&lt;/code&gt; or &lt;code&gt;reject()&lt;/code&gt; sets its &lt;code&gt;state&lt;/code&gt; value accordingly.&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
When using promises, it’s very easy to omit the error callback. But if you do, you’ll never get &lt;em&gt;any&lt;/em&gt; indication something went wrong. At the very least, the final promise in your chain should have an error callback. See the section further down about swallowed errors for more info.
&lt;/div&gt;

&lt;h3 id=&quot;unexpected-errors-should-also-lead-to-rejection&quot;&gt;Unexpected Errors Should Also Lead to Rejection&lt;/h3&gt;
&lt;p&gt;So far our error handling only accounts for known errors. It’s possible an unhandled exception will happen, completely ruining everything. It’s essential that the promise implementation catch these exceptions and reject accordingly.&lt;/p&gt;
&lt;p&gt;This means that &lt;code&gt;resolve()&lt;/code&gt; should get wrapped in a try/catch block&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;comment&quot;&gt;// ... as before&lt;/span&gt;
  } &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) {
    reject(e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s also important to make sure the callbacks given to us by the caller don’t throw unhandled exceptions. These callbacks are called in &lt;code&gt;handle()&lt;/code&gt;, so we end up with&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(deferred)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// ... as before&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret;
  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; {
    ret = handlerCallback(value);
  } &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) {
    handler.reject(e);
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
  }

  handler.resolve(ret);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;promises-can-swallow-errors-&quot;&gt;Promises can Swallow Errors!&lt;/h3&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
It’s possible for a misunderstanding of promises to lead to completely swallowed errors! This trips people up a lot
&lt;/div&gt;

&lt;p&gt;Consider this example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSomeJson&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(resolve, reject)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; badJson = &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;uh oh, this is not JSON at all!&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;;
    resolve(badJson);
  });
}

getSomeJson().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(json)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);
  console.log(obj);
}, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(error)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;'uh oh'&lt;/span&gt;, error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;fiddle&quot; target=&quot;_blank&quot; href=&quot;http://jsfiddle.net/city41/M7SRM/3/&quot;&gt;fiddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What is going to happen here? Our callback inside &lt;code&gt;then()&lt;/code&gt; is expecting some valid JSON. So it naively tries to parse it, which leads to an exception. But we have an error callback, so we’re good, right?&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
&lt;strong&gt;Nope.&lt;/strong&gt; &lt;em&gt;That error callback will not be invoked!&lt;/em&gt; If you run this example via the above fiddle, you will get no output at all. No errors, no nothing. Pure &lt;em&gt;chilling&lt;/em&gt; silence.
&lt;/div&gt;

&lt;p&gt;Why is this? Since the unhandled exception took place in our callback to &lt;code&gt;then()&lt;/code&gt;, it is being caught inside of &lt;code&gt;handle()&lt;/code&gt;. This causes &lt;code&gt;handle()&lt;/code&gt; to reject the promise that &lt;code&gt;then()&lt;/code&gt; returned, not the promise we are already responding to, as that promise has already properly resolved.&lt;/p&gt;
&lt;div class=&quot;callout wisdom&quot;&gt;
Always remember, inside of &lt;code&gt;then()&lt;/code&gt;‘s callback, the promise you are responding to has already resolved. The result of your callback will have no influence on this promise
&lt;/div&gt;

&lt;p&gt;If you want to capture the above error, you need an error callback further downstream&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;getSomeJson().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(json)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);
  console.log(obj);
}).then(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(error)&lt;/span&gt; {&lt;/span&gt;
  console.log(&lt;span class=&quot;string&quot;&gt;&quot;an error occured: &quot;&lt;/span&gt;, error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we will properly log the error.&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
In my experience, this is the biggest pitfall of promises. Read onto the next section for a potentially better solution
&lt;/div&gt;

&lt;h3 id=&quot;done-to-the-rescue&quot;&gt;done() to the Rescue&lt;/h3&gt;
&lt;p&gt;Most (but not all) promise libraries have a &lt;code&gt;done()&lt;/code&gt; method. It’s very similar to &lt;code&gt;then()&lt;/code&gt;, except it avoids the above pitfalls of &lt;code&gt;then()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;done()&lt;/code&gt; can be called whenever &lt;code&gt;then()&lt;/code&gt; can. The key differences are it does not return a promise, and any unhandled exception inside of &lt;code&gt;done()&lt;/code&gt; is not captured by the promise implementation. In other words, &lt;code&gt;done()&lt;/code&gt; represents when the entire promise chain has fully resolved. Our &lt;code&gt;getSomeJson()&lt;/code&gt; example can be more robust using &lt;code&gt;done()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;getSomeJson().done(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(json)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// when this throws, it won't be swallowed&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);
  console.log(obj);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;done()&lt;/code&gt; also takes an error callback, &lt;code&gt;done(callback, errback)&lt;/code&gt;, just like &lt;code&gt;then()&lt;/code&gt; does, and since the entire promise resolution is, well, done, you are assured of being informed of any errors that erupted.&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
&lt;code&gt;done()&lt;/code&gt; is not part of the Promises/A+ spec (at least not yet), so your promise library of choice might not have it.
&lt;/div&gt;


&lt;h2 id=&quot;promise-resolution-needs-to-be-async&quot;&gt;Promise Resolution Needs to be Async&lt;/h2&gt;
&lt;p&gt;Early in the article we cheated a bit by using &lt;code&gt;setTimeout&lt;/code&gt;. Once we fixed that hack, we’ve not used setTimeout since. But the truth is the Promises/A+ spec requires that promise resolution happen asynchronously. Meeting this requirement is simple, we simply need to wrap most of &lt;code&gt;handle()&lt;/code&gt;‘s implementation inside of a &lt;code&gt;setTimeout&lt;/code&gt; call&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(handler)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;'pending'&lt;/span&gt;) {
    deferred = handler;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
  }
  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// ... as before&lt;/span&gt;
  }, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is all that is needed. In truth, real promise libraries don’t tend to use &lt;code&gt;setTimeout&lt;/code&gt;. If the library is NodeJS oriented it will possibly use &lt;code&gt;process.nextTick&lt;/code&gt;, for browsers it might use the new &lt;code&gt;setImmediate&lt;/code&gt; or a &lt;a href=&quot;https://github.com/NobleJS/setImmediate&quot;&gt;setImmediate shim&lt;/a&gt; (so far only IE supports setImmediate), or perhaps an asynchronous library such as Kris Kowal’s &lt;a href=&quot;https://github.com/kriskowal/asap&quot;&gt;asap&lt;/a&gt; (Kris Kowal also wrote &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;, a popular promise library)&lt;/p&gt;
&lt;h3 id=&quot;why-is-this-async-requirement-in-the-spec-&quot;&gt;Why Is This Async Requirement in the Spec?&lt;/h3&gt;
&lt;p&gt;It allows for consistency and reliable execution flow. Consider this contrived example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = doAnOperation();
invokeSomething();
promise.then(wrapItAllUp);
invokeSomethingElse();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is the call flow here? Based on the naming you’d probably guess it is &lt;code&gt;invokeSomething()&lt;/code&gt; -&amp;gt; &lt;code&gt;invokeSomethingElse()&lt;/code&gt; -&amp;gt; &lt;code&gt;wrapItAllUp()&lt;/code&gt;. But this all depends on if the promise resolves synchronously or asynchronously in our current implementation. If &lt;code&gt;doAnOperation()&lt;/code&gt; works asynchronously, then that is the call flow. But if it works synchronously, then the call flow is actually &lt;code&gt;invokeSomething()&lt;/code&gt; -&amp;gt; &lt;code&gt;wrapItAllUp()&lt;/code&gt; -&amp;gt; &lt;code&gt;invokeSomethingElse()&lt;/code&gt;, which is probably bad.&lt;/p&gt;
&lt;p&gt;To get around this, promises &lt;strong&gt;always&lt;/strong&gt; resolve asynchronously, even if they don’t have to. It reduces surprise and allows people to use promises without having to take into consideration asynchronicity when reasoning about their code.&lt;/p&gt;
&lt;div class=&quot;callout pitfall&quot;&gt;
Promises always require at least one more iteration of the event loop to resolve. This is not necessarily true of the standard callback approach.
&lt;/div&gt;

&lt;h2 id=&quot;before-we-wrap-up-then-promise&quot;&gt;Before We Wrap Up … then/promise&lt;/h2&gt;
&lt;p&gt;There are many, full featured, promise libraries out there. The &lt;a href=&quot;https://github.com/then&quot;&gt;then&lt;/a&gt; organization’s &lt;a href=&quot;https://github.com/then/promise&quot;&gt;promise&lt;/a&gt; library takes a simpler approach. It is meant to be a simple implementation that meets the spec and nothing more. If you take a look at &lt;a href=&quot;https://github.com/then/promise/blob/master/core.js&quot;&gt;their implementation&lt;/a&gt;, you should see it looks quite familiar. then/promise was the basis of the code for this article, we’ve &lt;em&gt;almost&lt;/em&gt; built up the same promise implementation. Thanks to Nathan Zadoks and Forbes Lindsay for their great library and work on JavaScript promises. Forbes Lindsay is also the guy behind the &lt;a href=&quot;http://promisejs.org/&quot;&gt;promisejs.org&lt;/a&gt; site mentioned at the start.&lt;/p&gt;
&lt;p&gt;There are some differences in the real implementation and what is here in this article. That is because there are more details in the Promises/A+ spec that I have not addressed. I recommend &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;reading the spec&lt;/a&gt;, it is short and pretty straightforward. &lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you made it this far, then thanks for reading! We’ve covered the core of promises, which is the only thing the spec addresses. Most implementations offer much more functionality, such as &lt;code&gt;all()&lt;/code&gt;, &lt;code&gt;spread()&lt;/code&gt;, &lt;code&gt;race()&lt;/code&gt;, &lt;code&gt;denodeify()&lt;/code&gt; and much more. I recommend browsing the &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md&quot;&gt;API docs for Bluebird&lt;/a&gt; to see what all is possible with promises. &lt;/p&gt;
&lt;p&gt;Once I came to understand how promises worked and their caveats, I came to really like them. They have led to very clean and elegant code in my projects. There’s so much more to talk about too, this article is just the beginning!&lt;/p&gt;
&lt;p&gt;If you enjoyed this, you should &lt;a href=&quot;http://twitter.com/cityfortyone&quot;&gt;follow me on Twitter&lt;/a&gt; to find out when I write another guide like this.&lt;/p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;
&lt;p&gt;More great articles on promises&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://promisejs.org/&quot;&gt;promisejs.org&lt;/a&gt; — great tutorial on promises (already mentioned it a few times)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kriskowal/q/blob/v1/design/README.js&quot;&gt;Q’s Design Rationale&lt;/a&gt; — an article much like this one, but goes into even more detail. By Kris Kowal, creator of Q&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/domenic/promises-unwrapping/issues/19&quot;&gt;Some debate over whether done() is a good thing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://solutionoptimist.com/2013/12/27/javascript-promise-chains-2/&quot;&gt;Flattening Promise Chains&lt;/a&gt; by Thomas Burleson. A nice article that goes into more advanced usage of promises. If my article is the “what”, then Thomas’s is a nice look at the “why”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Found a mistake?&lt;/strong&gt; if I made an error and you want to let me know, please &lt;a href=&quot;mailto:matt.e.greer@gmail.com&quot;&gt;email me&lt;/a&gt; or &lt;a href=&quot;https://github.com/city41/blog/issues&quot;&gt;file an issue&lt;/a&gt;. Thanks!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CoffeeScript's Time is Waning For Me</title>
      <link>http://mattgreer.org/articles/coffeescripts-time-is-waning/</link>
      <pubDate>Sat, 11 Jan 2014 17:00:00 -0700</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/coffeescripts-time-is-waning/</guid>
      <author></author>
      <description>&lt;p&gt;CoffeeScript was a welcome addition when it first arrived. Nowadays though, I am
finding its benefits are decreasing, and its drawbacks are increasing. I plan to
no longer use CoffeeScript in my future projects, here is why.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I’ve tweeted about this here and there, and today someone asked me why. 
So I thought I’d blog it out.&lt;/p&gt;
&lt;h2 id=&quot;ecmascript-6-has-the-key-coffeescript-features-i-like&quot;&gt;EcmaScript 6 Has the Key CoffeeScript Features I Like&lt;/h2&gt;
&lt;p&gt;arrow functions, destructuring assignment and shorthand object literals are my
favorite features of CoffeeScript. They are all in EcmaScript 6. This is the
biggest reason why CoffeeScript is becoming less relevant to me. For sure, ES6
has a ways to go and not even Node has these features yet. But by the time my
current project is done, Node’s Harmony support will likely meet my needs.&lt;/p&gt;
&lt;h2 id=&quot;ecmascript-6-has-none-of-the-coffeescript-features-i-hate&quot;&gt;EcmaScript 6 Has None of the CoffeeScript Features I Hate&lt;/h2&gt;
&lt;h3 id=&quot;significant-whitespace&quot;&gt;significant whitespace&lt;/h3&gt;
&lt;p&gt;I &lt;em&gt;hate&lt;/em&gt; significant whitespace, and always have. I downright think it’s wrong.
I grudgingly accepted it when adopting CoffeeScript. I really look forward to no
longer dealing with it.&lt;/p&gt;
&lt;p&gt;As my project grows in size, significant whitespace becomes more and more of a
problem. It’s just plain not readable or visually parsable. Your files become a
wall of dense text. Damn you Python, damn you to hell!&lt;/p&gt;
&lt;h3 id=&quot;implicit-return&quot;&gt;implicit return&lt;/h3&gt;
&lt;p&gt;Using CoffeeScript has also made me dislike implicit return. Saving one keyword
is not worth this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt;((&lt;span class=&quot;title&quot;&gt;provide&lt;/span&gt;) -&amp;gt;&lt;/span&gt;
  provide.value(&lt;span class=&quot;string&quot;&gt;'foo'&lt;/span&gt;, bar)
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# &amp;lt;-- bleh&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;without &lt;code&gt;return&lt;/code&gt; (or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, all ugly), the return value is
&lt;code&gt;provide.value()&lt;/code&gt;s return value (a function), which is not what &lt;code&gt;module()&lt;/code&gt;
wants here (leading to an error). I often have to do this to avoid loops
becoming unneeded expressions too. The real problem here though is not the
ugliness, but the occassional surprises. I don’t even use implicit return, so a
double whammy for me.&lt;/p&gt;
&lt;h2 id=&quot;ecmascript-5-is-ubiquitous-for-me&quot;&gt;EcmaScript 5 is Ubiquitous for Me&lt;/h2&gt;
&lt;p&gt;I have to support IE8 at work, but not at home. ES5’s features (especially the
array functions) negate even more of CoffeeScript’s features for me.
CoffeeScript compiling all of its loop constructs into a standard for loop is a
nice little bonus though.&lt;/p&gt;
&lt;h2 id=&quot;open-source-code-is-better-written-in-javascript&quot;&gt;Open Source Code is Better Written in JavaScript&lt;/h2&gt;
&lt;p&gt;If you’re contributing to the JS community, you’re better off writing in
JavaScript. More people will contribute and/or adopt your code. &lt;/p&gt;
&lt;h2 id=&quot;tooling-support&quot;&gt;Tooling Support&lt;/h2&gt;
&lt;p&gt;Tooling support for CoffeeScript is pretty darn good. But it’s not
perfect. It &lt;em&gt;is&lt;/em&gt; perfect with JavaScript, it has to be. This is a minor point, but
eliminating even a little bit of friction is a good thing. Tools all tend
to support CoffeeScript just a little bit differently: where they dump the
compiled JS, how to specify wrap, etc. &lt;/p&gt;
&lt;p&gt;Not having to &lt;code&gt;grunt watch&lt;/code&gt; your JS is another minor win.&lt;/p&gt;
&lt;h2 id=&quot;coffeescript-isn-t-irrelevant-yet&quot;&gt;CoffeeScript Isn’t Irrelevant Yet&lt;/h2&gt;
&lt;p&gt;Even for me, and it won’t be for a while yet. But I do suspect I’m on my last CS
project. If you need to support old IEs, want to use PhantomJS, etc, then CS is
still very welcome. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>Dynamic Lighting and Shadows in my 2d Game</title>
      <link>http://mattgreer.org/articles/dynamic-lighting-and-shadows/</link>
      <pubDate>Tue, 16 Oct 2012 18:00:00 -0600</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/dynamic-lighting-and-shadows/</guid>
      <author></author>
      <description>&lt;p&gt;I’m working on a stealth action game where shadows will play a big role in the gameplay. Using WebGL shaders, I implemented dynamic lighting and shadows. This post is the blog post I wish existed before I started :) Gritty details on how I implemented these below…&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; style=&quot;margin-top: 3em; margin-bottom: 3em;&quot; src=&quot;http://www.youtube.com/embed/ZMyg5erp-vk&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;part-one-dynamic-lighting&quot;&gt;Part one: dynamic lighting&lt;/h2&gt;
&lt;p&gt;I was inspired by &lt;a href=&quot;http://www.reddit.com/r/gamedev/comments/115f3y/how_to_dynamic_lighting_on_sprites/&quot;&gt;this post&lt;/a&gt; on Reddit, where aionskull used normal maps in Unity to dynamically light up his sprites. gpillow also posted in the comments how he had done &lt;a href=&quot;https://love2d.org/forums/viewtopic.php?f=5&amp;amp;t=11076&quot;&gt;something similar&lt;/a&gt; in Love2D. &lt;a href=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/pixel_shading.gif&quot;&gt;Here’s a large gif illustrating gpillow’s results&lt;/a&gt;. I’d just include the gif here, but it’s 8 megs. Thanks to jusksmit for making the gif.&lt;/p&gt;
&lt;p&gt;So, what is dynamic lighting? It’s a 3D graphics technique where a light source lights up objects in the scene. It’s dynamic as the lighting effects update in real time as the light source moves around. This is pretty standard stuff in the 3D world and easy to translate into a 2D environment, assuming you can take advantage of shaders.&lt;/p&gt;
&lt;p&gt;The key is the angle the light hits a surface indicates how much the surface lights up.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/lighting.gif&quot; alt=&quot;lighting diagram&quot;&gt;&lt;/p&gt;
&lt;p&gt;and the key to &lt;em&gt;that&lt;/em&gt; is the normal vector. A vector which indicates which way a surface is facing. In the above diagram, the arrow sticking out of the center of the panel is the normal vector. You can see that when the light’s rays come in at a shallower angle, the panel is less influenced by the light and not lit up as much. So in the end, the algorithm is quite simple, as that angle increases, have the light source influence less. A simple way to calculate the influence is to calculate the dot product between the light vector and the normal vector.&lt;/p&gt;
&lt;h3 id=&quot;dynamic-lighting-in-a-2d-environment&quot;&gt;dynamic lighting in a 2d environment&lt;/h3&gt;
&lt;p&gt;That’s all well and good, but how do you have normal vectors in a 2d game? There aren’t any real 3D objects in the traditional sense, but textures can step in to provide the needed info. I created &lt;em&gt;normal maps&lt;/em&gt; for the two houses in the above video, and use them to calculate the lighting:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/mansionNormals.png&quot; alt=&quot;mansion normals&quot;&gt;&lt;/p&gt;
&lt;p&gt;For starters, you can see the actual house sprite has no shading drawn into it. Then the normal map encodes the normals for each pixel into a color. A vector needs to be specified with (x,y,z) coordinates, and an image has r,g and b values. So the encoding into the image is easy to do. Take the front face of the house, which is facing due south giving the normal vector values of &lt;code&gt;[x:0, y:0.5, z:0]&lt;/code&gt;. RGB values are positive, so need to shift the values up by 0.5 to force everything positive:  &lt;code&gt;[x:0.5, y:1, z:0.5]&lt;/code&gt;. And RGB values are normally represented as bytes, so multiply each value by &lt;code&gt;255&lt;/code&gt;, yielding (rounded up): &lt;code&gt;[x:128, y:255, z:128]&lt;/code&gt;, or in other words, this bright green &lt;span style=&quot;display:inline-block; width: 30px; height: 15px; background-color: rgb(128, 255, 128)&quot;&gt;&amp;nbsp;&lt;/span&gt;, the same green in the normal map image.&lt;/p&gt;
&lt;p&gt;With our normals in tow, we’re ready to have the graphics card do its magic. My game is using &lt;a href=&quot;http://www.impactjs.com/&quot;&gt;ImpactJS&lt;/a&gt;, which is very compatibile with &lt;a href=&quot;https://github.com/gameclosure/webgl-2d&quot;&gt;WebGL2D&lt;/a&gt; Using WebGL2D, it was easy to add an additional fragment shader to implement the lighting:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef GL_ES&lt;/span&gt;
  precision highp &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;;
&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec3 lightDirection;
uniform vec4 lightColor;

&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) {
  &lt;span class=&quot;comment&quot;&gt;// pull the normal vector out of the texture&lt;/span&gt;
  vec4 rawNormal = texture2D(uSampler, vTextureCoord);

  &lt;span class=&quot;comment&quot;&gt;// if the alpha channel is zero, then don't do lighting here&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(rawNormal.a == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;) {
    gl_FragColor = vec4(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);
  } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {

    &lt;span class=&quot;comment&quot;&gt;// translate from 0 to 1 to -.5 to .5&lt;/span&gt;
    rawNormal -= &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;;

    &lt;span class=&quot;comment&quot;&gt;// figure out how much the lighting influences this pixel&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; lightWeight = 
      dot(normalize(rawNormal.xyz), normalize(lightDirection));

    lightWeight = max(lightWeight, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;);

    &lt;span class=&quot;comment&quot;&gt;// and drop the pixel in&lt;/span&gt;
    gl_FragColor = lightColor * lightWeight;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Couple final points here. This is &lt;em&gt;per fragment lighting&lt;/em&gt;, which is a bit different from per vertex lighting. Since the vertices are completely
irrelevant in 2D rendering (just 4 vertices to drop the texture into the scene), have no choice but to do per fragment lighting. No problem, per
fragment lighting is more accurate anyway. Also this shader is only rendering the light itself. It assumes the main sprite has already been drawn. I have to admit I am cheating a little bit, as I am setting my &lt;code&gt;lightColor&lt;/code&gt; to a dark grey, and not sending out light but actually darkness. This
is because lighting the pixels up makes them looked washed out. There are ways to resolve this, but for now I’m cheating a smidge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/lightingExamples.png&quot; alt=&quot;lighting examples&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;part-two-casting-shadows&quot;&gt;part two: casting shadows&lt;/h2&gt;
&lt;p&gt;Casting shadows in 3D environments is a well solved problem, using techniques like &lt;a href=&quot;http://en.wikipedia.org/wiki/Ray_tracing_(graphics&quot;&gt;raytracing&lt;/a&gt;) or &lt;a href=&quot;http://en.wikipedia.org/wiki/Shadow_mapping&quot;&gt;shadow mapping&lt;/a&gt; casting shadows in the scene is pretty easy to accomplish. I struggled to find an implementation in my 2D environment that I was happy with. I think I came up with a good solution, but for sure it has drawbacks.&lt;/p&gt;
&lt;p&gt;In short, draw a line from a fragment (aka pixel) in the scene to the sun and see if anything gets in the way. if something does, that pixel is in the shade, else it’s in the sun. In the end it’s actually pretty simple.&lt;/p&gt;
&lt;p&gt;The shader will get &lt;code&gt;xyAngle&lt;/code&gt; and &lt;code&gt;zAngle&lt;/code&gt; passed into it, indicating where the sun is. Since the sun is so far away, these two angles are the same for all pixels, as sunrays are effectively parallel to each other.&lt;/p&gt;
&lt;p&gt;The other key piece of info the shader receives is the &lt;em&gt;height map&lt;/em&gt; for the world. This height map indicates how tall everything is, buildings, trees, etc. If a pixel is occupied by a building, then that pixel’s value will be something like 10, to indicate that building is 10 pixels tall.&lt;/p&gt;
&lt;p&gt;So starting at the current pixel and using &lt;code&gt;xyAngle&lt;/code&gt;, we move over just a bit towards the sun in the x/y direction. Using the height map, we figure out how tall the pixel is at this location. If the pixel here is the same height or lower, then we keep moving towards the sun until we find a pixel that is taller than the current pixel.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/xyAngle.gif&quot; alt=&quot;xy angle&quot;&gt;&lt;/p&gt;
&lt;p&gt;Once we find a pixel that has some height to it, we need to see if it’s tall enough to block the sun. Using &lt;code&gt;zAngle&lt;/code&gt;, we determine how tall this pixel needs to be to block the sun:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/zAngle.gif&quot; alt=&quot;z angle&quot;&gt;&lt;/p&gt;
&lt;p&gt;If it is tall enough, we are done, this pixel is in the shade. Otherwise we keep going. Eventually we give up and declare the pixel to be in the sun (currently I have that hard coded to 100 steps, which so far is working well)&lt;/p&gt;
&lt;p&gt;Here is the code for the shader in simplified/pseudo form&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; alpha = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isInShadow()) {
    alpha = &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;;
  }
  gl_FragColor = vec4(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alpha);
}

&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isInShadow() {
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; height = getHeight(currentPixel);
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; distance = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;

  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; ++i) {
    distance += moveALittle();

    vec2 otherPixel = getPixelAt(distance);
    &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; otherHeight = getHeight(otherPixel);

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(otherHeight &amp;gt; height) {
      &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; traceHeight = getTraceHeightAt(distance);
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(traceHeight &amp;lt;= otherHeight) {
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;
      }
    }
  }
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is the whole shebang:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef GL_ES&lt;/span&gt;
  precision highp &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;;
&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;

vec2 extrude(vec2 other, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; angle, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; length) {
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; x = length * &lt;span class=&quot;built_in&quot;&gt;cos&lt;/span&gt;(angle);
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; y = length * &lt;span class=&quot;built_in&quot;&gt;sin&lt;/span&gt;(angle);

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; vec2(other.x + x, other.y + y);
}

&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; getHeightAt(vec2 texCoord, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; xyAngle, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; distance,
    sampler2D heightMap) {

  vec2 newTexCoord = extrude(texCoord, xyAngle, distance);
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; texture2D(heightMap, newTexCoord).r;
}

&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; getTraceHeight(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; height, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; zAngle, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; distance) {
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; distance * &lt;span class=&quot;built_in&quot;&gt;tan&lt;/span&gt;(zAngle) + height;
}

&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isInShadow(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; xyAngle, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; zAngle, sampler2D heightMap,
    vec2 texCoord, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; step) {

  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; distance;
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; height;
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; otherHeight;
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; traceHeight;

  height = texture2D(heightMap, texCoord).r;

  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; ++i) {
    distance = step * &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;(i);
    otherHeight = getHeightAt(texCoord, xyAngle, distance, heightMap);

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(otherHeight &amp;gt; height) {
      traceHeight = getTraceHeight(height, zAngle, distance);
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(traceHeight &amp;lt;= otherHeight) {
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;
      }
    }
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
}

varying vec2 vTextureCoord;
uniform sampler2D uHeightMap;
uniform &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; uXYAngle;
uniform &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; uZAngle;
uniform &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; uMaxShadowSteps;
uniform &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; uTexStep;

&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; alpha = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isInShadow(uXYAngle, uZAngle, uHeightMap, uMaxShadowSteps,
     vTextureCoord, uTexStep)) {

    alpha = &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;;
  }

  gl_FragColor = vec4(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alpha);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;uTexStep&lt;/code&gt; uniform is how far to move over each time we check a nearby pixel. This is set to either &lt;code&gt;1/heightMap.width&lt;/code&gt; or &lt;code&gt;1/heightMap.height&lt;/code&gt; before invoking the shader. This is because textures in OpenGL are typically mapped from 0 to 1, so the inverse is how far to move to get to the next pixel.&lt;/p&gt;
&lt;h3 id=&quot;shadow-wrap-up&quot;&gt;shadow wrap up&lt;/h3&gt;
&lt;p&gt;Truth be told there are some minor details I’m leaving out in the above code, but the core idea is definitely there. One major problem with this approach is each pixel in the scene can only have one height. A good example of how this is a limitation is trees. I can tell the engine to cast a really low, long shadow for a tree, but the trunk will never show up in the shadow. This is because the overhang area at the bottom of the leaves is not recorded in the height map.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/shadow1.png&quot; alt=&quot;shadow example 1&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/dynamic-lighting-and-shadows/shadow2.png&quot; alt=&quot;shadow example 2&quot;&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Still Waking up at 5am to Code?</title>
      <link>http://mattgreer.org/articles/still-waking-up-at-5am/</link>
      <pubDate>Sun, 26  Aug 2012 18:00:00 -0600</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/still-waking-up-at-5am/</guid>
      <author></author>
      <description>&lt;p&gt;Back in January I posted an article about &lt;a href=&quot;http://mattgreer.org/articles/waking-up-at-5am-to-code/&quot;&gt;waking up at 5am to code&lt;/a&gt;. It seemed to really strike a chord with a lot of people. Lately I’ve been getting a handful of emails asking me if I still do this and where I’m at with it now. So I thought I’d post a quick follow up.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;kept-it-solidly-up-for-about-6-weeks&quot;&gt;Kept it solidly up for about 6 weeks&lt;/h2&gt;
&lt;p&gt;Waking up early to tackle personal projects is a good strategy. But it’s not without its cost. I managed to maintain it quite solidly for about 6 weeks. From there I found myself not waking up early on most weekend days for another few weeks. The early hours and extra load do take their toll, nothing is free unfortunately. I could feel my stress levels rising and overall just an extra level of feeling worn out. But how my day job is going is a factor there too.&lt;/p&gt;
&lt;h2 id=&quot;anything-to-show-for-all-this-&quot;&gt;Anything to show for all this?&lt;/h2&gt;
&lt;p&gt;My early hours were mostly dedicated to writing a little JavaScript game engine. One thing I did with it was create an animation &lt;a href=&quot;http://yaysarahandmatt.org/&quot;&gt;celebrating my wedding engagement&lt;/a&gt;. I’ve also been working on a game using the engine, an intro/preview of which can be found &lt;a href=&quot;http://mattgreer.org/media/labAdder/index.html&quot;&gt;here&lt;/a&gt;. I was pretty happy with my results and overall felt pretty darn productive.&lt;/p&gt;
&lt;h2 id=&quot;sporadic-from-there-on&quot;&gt;Sporadic from there on&lt;/h2&gt;
&lt;p&gt;I still do wake up early, but now it’s more in “spurts”. I will go for a week or two doing it, then take a break for a while. I also find my desire to do it depends on where I’m at inspiration wise. Lately I’ve also been getting more involved with local hack nights. Having a set aside “event” to do personal hacking I am finding is also a good way to accomplish productivity. Being both out of the house and the office to focus on personal projects really amps the focus for me. Experimenting and finding what works best is key.&lt;/p&gt;
&lt;h2 id=&quot;also-finding-time-for-down-time&quot;&gt;Also finding time for down time&lt;/h2&gt;
&lt;p&gt;My personality is very work oriented. I have a hard time relaxing and almost always want to be pushing forward on something. But lately I’ve been forcing myself to take certain weekends and 100% do nothing but relaxing, non-taxing things. They really do wonders for rejuvination and balance. Probably more than I’ve ever realized in the past. Related to the topic at hand, I have also woken up early just to then go for a nice long walk or watch morning news shows. I think my experiments in trying to hyper increase productivity have shown that down time is equally as important.&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Waking Up at 5am to Code</title>
      <link>http://mattgreer.org/articles/waking-up-at-5am-to-code/</link>
      <pubDate>Sun, 22 Jan 2012 17:00:00 -0700</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/waking-up-at-5am-to-code/</guid>
      <author></author>
      <description>&lt;p&gt;I’m currently experimenting with waking up at 5am to work on personal projects before heading to work.&lt;/p&gt;
&lt;p&gt;Someone on Hacker News once mentioned they do this, and it stuck in the back of my head ever since. I’ve been at this for two weeks thus far.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;the-basic-idea&quot;&gt;The basic idea&lt;/h2&gt;
&lt;p&gt;At 5am I jump out of bed and code for two hours, then get ready for work. I do this every day, including weekends. I maintain an online Kanban board which I groom/prep in the evenings while watching TV, to ensure I am ready to be productive the next morning.&lt;/p&gt;
&lt;h2 id=&quot;enjoying-the-work-is-key&quot;&gt;Enjoying the work is key&lt;/h2&gt;
&lt;p&gt;It’s 5am &lt;em&gt;and&lt;/em&gt; I will be also putting in a full day’s work afterwards. Not being stressed out or frustrated during this time is essential. I ensure this by working on truly personal projects that interest me and I have complete control over. I’m only two weeks in but so far no signs of getting worn out, in fact quite the opposite. It’s been pretty invigorating.&lt;/p&gt;
&lt;h2 id=&quot;advantages&quot;&gt;Advantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;At 5am things are very quiet and serene. Nobody is on IM, no one is texting or emailing me. I find myself very focused. I am also aware of the cost of these two hours, which motivates me to be even more to focus and use them efficiently. So far, I have found I am very productive.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have a well defined slot to do my work, and I am guaranteed at least 12 hours a week, typically 14-18 (how much I put in on a weekend can vary). This is very different from before when I’d try to carve time out of my life at the expense of other things. The strong structure has led to better time usage overall.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am only going to bed one hour earlier than I used to. To do this I do sacrifice a bit of reading time, and I get between 7-8 hours of sleep. But I’m (so far) ok with all of this&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;My evenings — and much of my weekend — are more relaxing. I can enjoy myself and unwind and not have a little voice in the back of my head telling me I really should be pushing forward on the game. If I want to work in the evening I can. But so far I am finding ~12 really good hours a week to be enough to propel my project forward at a comfortable pace. The itch to create is well satiated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;I am finding myself turning off the project thinking and daydreaming and being more in the moment for the rest of my day.&lt;/li&gt;
&lt;li&gt;When I head off to work I’m more awake, and feeling good about already having been productive.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;disadvantages&quot;&gt;Disadvantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;At first waking up at 5am was very painful. But I am adjusting.&lt;/li&gt;
&lt;li&gt;I may be wearing myself down more than I realize, and may not really know that for a while yet&lt;/li&gt;
&lt;li&gt;I can’t listen to music as effectively as I’d like, lest I wake my girlfriend up. This may become an advantage though…&lt;/li&gt;
&lt;li&gt;This could interfere with weekend plans. I do doubt it though, I’m not so young anymore and not really a late nighter these days.&lt;/li&gt;
&lt;li&gt;Getting in a pinch and not making much progress during these early morning sessions may be a drag on the rest of the day. Hopefully that never happens, but it may eventually.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;why-the-weekend-too-&quot;&gt;Why the weekend too?&lt;/h2&gt;
&lt;p&gt;I find I am more likely to stick with something like this if I do it every day. Letting myself sleep in on the weekends makes me more likely to then sleep in on Monday too. It can unravel from there. That’s just my personality though.&lt;/p&gt;
&lt;h2 id=&quot;the-kanban-board&quot;&gt;The Kanban board&lt;/h2&gt;
&lt;p&gt;I’ve really become a fan of Kanban, even when just working by myself. I do feel this is a key element in this. It keeps me focused, forces me to break down my tasks into managable chunks (ideally finishable in 2 hours), and makes sure I am never messing around trying to think of where to go next.&lt;/p&gt;
&lt;p&gt;I got requests to see a screenshot of my board, so here it is (click for full size):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mattgreer.org/articles/waking-up-at-5am-to-code/kanban.png&quot; alt=&quot;kanban&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;other-ideas&quot;&gt;Other ideas&lt;/h2&gt;
&lt;p&gt;First I plan to see if this will really stick. I am optimisic it will. If it does, I think might look into a coffee pot that can have a nice cup waiting for me right when I get up. &lt;/p&gt;
&lt;p&gt;I gave the standing desk idea a shot a while back and ultimately went back to sitting. But maybe for two hours in the morning standing would be more ideal? Worth looking into.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Yokul - Google Charts Reimplemented in a Local JS Canvas</title>
      <link>http://mattgreer.org/articles/yokul/</link>
      <pubDate>Sat, 04 Jun 2011 18:00:00 -0600</pubDate>
      <guid isPermaLink="true">http://mattgreer.org/articles/yokul/</guid>
      <author></author>
      <description>&lt;p&gt;&lt;a href=&quot;https://github.com/city41/yokul&quot;&gt;Yokul&lt;/a&gt; is a little JavaScript experiment I’ve been playing with in my free time. Using the same query string you’d normally send to the &lt;a href=&quot;http://code.google.com/apis/chart/image/&quot;&gt;Google Image Chart API&lt;/a&gt; a local chart is created on the client using an HTML5 canvas.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;yokul.css&quot;&gt;&lt;/link&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/js/yokul/yokul.min.js&quot;&gt;&lt;/script&gt;

&lt;div class=&quot;charts&quot;&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?chxr=2,-5,100&amp;chxs=0,676767,10.5,0,l,676767&amp;chxt=y,x&amp;chbh=24,2,1&amp;chs=400x245&amp;cht=bvs&amp;chco=BBCCED,FF9900,3366CC&amp;chds=0,95,0,100,0,105&amp;chd=t:44,33,30,20,30,40,30,20,55|0,0,40,0,40,0,40,0,0|0,20,0,67,0,20,0,63,0&amp;chdl=water|orange stripes|blue stripes&amp;&amp;chma=|40,40&amp;chtt=Chart+Fish+Done+With+Google&amp;chts=0C3890,20.5&amp;chxl=0:|deep|shallow|air&quot; /&gt;&lt;br&gt;
&lt;img data-src=&quot;http://chart.apis.google.com/chart?chxr=2,-5,100&amp;chxs=0,676767,10.5,0,l,676767&amp;chxt=y,x&amp;chbh=24,2,1&amp;chs=400x245&amp;cht=bvs&amp;chco=BBCCED,FF9900,3366CC&amp;chds=0,95,0,100,0,105&amp;chd=t:44,33,30,20,30,40,30,20,55|0,0,40,0,40,0,40,0,0|0,20,0,67,0,20,0,63,0&amp;chdl=water|orange stripes|blue stripes&amp;&amp;chma=|40,40&amp;chtt=Chart+Fish+Done+With+Yokul&amp;chts=0C3890,20.5&amp;chxl=0:|deep|shallow|air&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Here is a &lt;a href=&quot;http://mattgreer.org/articles/yokul/VerticalBar.min.html&quot;&gt;page of charts&lt;/a&gt; to play with&lt;/p&gt;
&lt;h2 id=&quot;advantages&quot;&gt;Advantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Open source and completely runs on the client, no data is sent to any third parties&lt;/li&gt;
&lt;li&gt;If your site has a lot of charts, this will save a lot of bandwidth. Granted it’s saving Google’s and your user’s bandwidth so you may not care&lt;/li&gt;
&lt;li&gt;It can render many charts much faster than Google can, limited only by the power of the user’s machine&lt;/li&gt;
&lt;li&gt;No need to send Google Charts a POST for complex chart definitions, Yokul will take a query string of any length&lt;/li&gt;
&lt;li&gt;Some of Google’s limitations like chart size are not present in Yokul. Want to make a 10,000x10,000 pixel chart? Have at it&lt;/li&gt;
&lt;li&gt;No internet connection is required for Yokul to work&lt;/li&gt;
&lt;li&gt;Animating a Yokul chart will be pretty easy to do and is high on the list of things to do next&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;disadvantages&quot;&gt;Disadvantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Your user must have JavaScript enabled and a modern browser to see the chart&lt;/li&gt;
&lt;li&gt;Yokul, so far, doesn’t come even close to implementing all of Google Charts and if it ever does, it’ll be a while&lt;/li&gt;
&lt;li&gt;Not a trivial drop in replacement, to use Yokul you do need to change your markup a bit (see below)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;yokul-depends-on&quot;&gt;Yokul Depends On&lt;/h2&gt;
&lt;p&gt;A browser having Canvas. That’s about it. No other JavaScript library is required.&lt;/p&gt;
&lt;h2 id=&quot;what-works-so-far&quot;&gt;What Works So Far&lt;/h2&gt;
&lt;p&gt;So far just vertical bar charts (grouped, stacked and overlapped) are implemented. There are some parameters that are not implemented, others that have bugs and others that are only partially implemented. See the &lt;a href=&quot;/VerticalBar.min.html&quot;&gt;sample page&lt;/a&gt; for a decent overview of what Yokul is currently capable of&lt;/p&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Grab &lt;a href=&quot;https://github.com/city41/yokul/raw/master/min/yokul.min.js&quot;&gt;yokul.min.js&lt;/a&gt; and reference it&lt;/li&gt;
&lt;li&gt;Change all the &lt;code&gt;src&lt;/code&gt; attributes in your Google Chart images to &lt;code&gt;data-src&lt;/code&gt; attributes&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;YOKUL.convertAllImages()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;showing-debug-info-and-errors&quot;&gt;Showing debug info and errors&lt;/h2&gt;
&lt;p&gt;Yokul is very early at this point, you will certainly run into issues. Mostly you’ll find some of your favorite chart types and/or parameters aren’t implemented yet. Yokul will let you know if you set up a debug output div for it.&lt;/p&gt;
&lt;p&gt;Create a div on your page that Yokul can write to. Tell Yokul where this div is with &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;  YOKUL.debugOutput = &lt;span class=&quot;string&quot;&gt;&quot;idOfYourDebugDiv&quot;&lt;/span&gt;;
  YOKUL.logOutput = { info: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;, warning: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, error: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ideally do this before you do anything else with Yokul. Here is the debug output from creating the above chart:&lt;/p&gt;
&lt;div id=&quot;debugOutputDiv&quot;&gt;&lt;/div&gt;

&lt;p&gt;You will need to set up some CSS styles for this output to look nice, view the source of this page to see my styles&lt;/p&gt;&lt;/p&gt;
&lt;h2 id=&quot;converting-just-one-image&quot;&gt;Converting just one image&lt;/h2&gt;
&lt;p&gt;If &lt;code&gt;convertAllImages()&lt;/code&gt; is too course for you, you can call &lt;code&gt;YOKUL.chartCreator.create(id, [query])&lt;/code&gt;. Where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; is a DOM id of an img element. This img’s src will be set to the generated chart image&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;query&lt;/strong&gt; the chart query string you’d normally send to Google. This is optional and if not provided Yokul will try and find the query string in the img element&lt;/li&gt;
&lt;/ul&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  YOKUL.debugOutput = &quot;debugOutputDiv&quot;;
  YOKUL.logOutput = { info: false, warning: true, error: true };
  YOKUL.convertAllImages();
&lt;/script&gt;


</description>
    </item>
  </channel>
</rss>